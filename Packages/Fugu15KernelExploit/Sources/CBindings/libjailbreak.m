#include <dlfcn.h>
#import <Foundation/Foundation.h>
#import <IOKit/IOKitLib.h>

NSString* generateJBRAND()
{
    uint64_t value = ((uint64_t)arc4random()) | ((uint64_t)arc4random())<<32;
    uint8_t check = value>>8 ^ value >> 16 ^ value>>24 ^ value>>32 ^ value>>40 ^ value>>48 ^ value>>56;
    uint64_t JBRAND = (value & ~0xFF) | check;
    return [NSString stringWithFormat:@"%016llX", JBRAND];
}

BOOL checkJBRAND(NSString* str)
{
    char* endp=NULL;
    unsigned long value = strtoul(str.UTF8String, &endp, 16);
    if(!endp || *endp!='\0')
        return NO;
    
   uint8_t check = value>>8 ^ value >> 16 ^ value>>24 ^ value>>32 ^ value>>40 ^ value>>48 ^ value>>56;
   return check == (uint8_t)value;
}

NSString* __find_jbroot()
{
    //jbroot path may change when re-randomize it
    NSString * jbroot = nil;
    NSArray *subItems = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:@"/var/containers/Bundle/Application/" error:nil];
    for (NSString *subItem in subItems) {
        if ([subItem hasPrefix:@".jbroot-"]) {
            jbroot = [@"/var/containers/Bundle/Application/" stringByAppendingPathComponent:subItem];
            break;
        }
    }
    return jbroot;
}

NSString *jbrootPath(NSString *path)
{
    NSString* jbroot = __find_jbroot();
    assert(jbroot != NULL); //to avoid [nil stringByAppendingString:
    return [jbroot stringByAppendingPathComponent:path];
}

void *libJailbreakHandle = NULL;
void *loadLibJailbreak(void)
{
    if(!__find_jbroot()) return NULL;
	if (libJailbreakHandle) return libJailbreakHandle;
	libJailbreakHandle = dlopen(jbrootPath(@"/basebin/libjailbreak.dylib").UTF8String, RTLD_NOW);
	return libJailbreakHandle;
}

#include <sys/mount.h>
BOOL __isOtherJailbreakActived()
{
    if(access("/dev/md0", F_OK)==0) {
        return YES;
    }
    
    if(access("/dev/rmd0", F_OK)==0) {
        return YES;
    }
    
    struct statfs fs;
    int sfsret = statfs("/usr/lib", &fs);
    if (sfsret == 0) {
        if(strcmp(fs.f_mntonname, "/usr/lib")==0) {
            return YES;
        }
    }
    
    return NO;
}

#define CS_CDHASH_LEN 20

typedef uint8_t cdhash_t[CS_CDHASH_LEN];

typedef struct trustcache_entry_v1
{
    cdhash_t hash;
    uint8_t hash_type;
    uint8_t flags;
} __attribute__((__packed__)) trustcache_entry_v1;

typedef struct s_trustcache_file_v1
{
    uint32_t version;
    uuid_t uuid;
    uint32_t length;
    trustcache_entry_v1 entries[];
} __attribute__((__packed__)) trustcache_file_v1;

void _trustcache_file_init(trustcache_file_v1 *file)
{
    memset(file, 0, sizeof(*file));
    file->version = 1;
    uuid_generate(file->uuid);
}
int _trustcache_file_sort_entry_comparator_v1(const void * vp1, const void * vp2)
{
    trustcache_entry_v1* tc1 = (trustcache_entry_v1*)vp1;
    trustcache_entry_v1* tc2 = (trustcache_entry_v1*)vp2;
    return memcmp(tc1->hash, tc2->hash, sizeof(cdhash_t));
}
void _trustcache_file_sort(trustcache_file_v1 *file)
{
    qsort(file->entries, file->length, sizeof(trustcache_entry_v1), _trustcache_file_sort_entry_comparator_v1);
}
int trustcache_file_build_from_cdhashes(cdhash_t *CDHashes, uint32_t CDHashCount, trustcache_file_v1 **tcOut)
{
    if (!CDHashes || CDHashCount == 0 || !tcOut) return -1;

    size_t tcSize = sizeof(trustcache_file_v1) + (sizeof(trustcache_entry_v1) * CDHashCount);
    trustcache_file_v1 *file = malloc(tcSize);
    _trustcache_file_init(file);

    file->length = CDHashCount;
    for (uint32_t i = 0; i < CDHashCount; i++) {
        memcpy(file->entries[i].hash, CDHashes[i], sizeof(cdhash_t));
        file->entries[i].hash_type = 2;
        file->entries[i].flags = 0;
    }
    _trustcache_file_sort(file);

    *tcOut = file;
    return 0;
}

int ensure_randomized_cdhash(const char* inputPath, void* cdhashOut);

NSData* loadBasebinTrustcache()
{
    cdhash_t* basebins_cdhashes=NULL;
    uint32_t basebins_cdhashesCount=0;
    
    NSDirectoryEnumerator<NSURL *> *directoryEnumerator = [[NSFileManager defaultManager] enumeratorAtURL:[NSURL fileURLWithPath:jbrootPath(@"/basebin/")] includingPropertiesForKeys:nil options:0 errorHandler:nil];
                                             
    for(NSURL* fileURL in directoryEnumerator)
    {
        cdhash_t cdhash={0};
        if(ensure_randomized_cdhash(fileURL.path.fileSystemRepresentation, cdhash) == 0) {
            basebins_cdhashes = realloc(basebins_cdhashes, (basebins_cdhashesCount+1) * sizeof(cdhash_t));
            memcpy(&basebins_cdhashes[basebins_cdhashesCount], cdhash, sizeof(cdhash_t));
            basebins_cdhashesCount++;
        }
    }
    
    trustcache_file_v1 *basebinTcFile = NULL;
    int r = trustcache_file_build_from_cdhashes(basebins_cdhashes, basebins_cdhashesCount, &basebinTcFile);
    
    free(basebins_cdhashes);
    
    NSData* tcData = [NSData dataWithBytes:basebinTcFile length:(sizeof(trustcache_file_v1)+sizeof(trustcache_entry_v1)*basebinTcFile->length)];
    
    free(basebinTcFile);
    
    return tcData;
}

#include <sys/stat.h>
int fixBootstrapSymlink(NSString* path)
{
    const char* jbpath = jbrootPath(path).fileSystemRepresentation;
    
    struct stat st={0};
    assert(lstat(jbpath, &st) == 0);
    if (!S_ISLNK(st.st_mode)) {
        return 0;
    }
    
    char link[PATH_MAX+1] = {0};
    assert(readlink(jbpath, link, sizeof(link)-1) > 0);
    if(link[0] != '/') {
        return 0;
    }

    NSString* _link = @(link).stringByStandardizingPath.stringByResolvingSymlinksInPath;
    
    NSString *pattern = @"^/var/containers/Bundle/Application/\\.jbroot-[0-9A-Z]{16}(/.+)$";
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:pattern options:0 error:nil];
    NSTextCheckingResult *match = [regex firstMatchInString:_link options:0 range:NSMakeRange(0, [_link length])];
    assert(match != nil);
    
    NSString* target = [_link substringWithRange:[match rangeAtIndex:1]];
    NSString* newlink = [@".jbroot" stringByAppendingPathComponent:target];
    
    assert(unlink(jbpath) == 0);
    assert(symlink(newlink.fileSystemRepresentation, jbpath) == 0);
    assert(access(jbpath, F_OK) == 0);
    
    return 0;
}

